<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDA & Генетический алгоритм</title>
    <link rel="stylesheet" href="bootstrap.min.css">
    <script src="d3.v7.min.js"></script>
    <script src="bootstrap.min.js"></script>
    <script src="plot.min.js"></script>
    <script src="papaparse.min.js"></script>
    <script src="d3-graphviz.min.js"></script>
</head>

<body>
    <div class="container">
        <h1>EDA анализ и построение бинарного дерева решений</h1>

        <div class="accordion" id="analysisAccordion">
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingData">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseData" aria-expanded="false" aria-controls="collapseData">
                        Загрузка данных
                    </button>
                </h2>
                <div id="collapseData" class="accordion-collapse collapse show" aria-labelledby="headingData"
                    data-bs-parent="#analysisAccordion">
                    <div class="accordion-body">
                        <input type="file" id="fileInput" accept=".csv">

                        <script>
                            const features = [];
                            const plots = {};
                            const history = [];
                            // var first_class, second_class, class_header;

                            // Обработчик события загрузки файла
                            document.getElementById('fileInput').addEventListener('change', function (e) {
                                const file = e.target.files[0];
                                const reader = new FileReader();

                                reader.onload = function (e) {
                                    let data = Papa.parse(e.target.result, { header: true }).data;
                                    // убрать последнюю строку, т.к. она поломана
                                    data = data.slice(0, data.length - 1);
                                    
                                    const headers = Object.keys(data[0]);

                                    // Очистка предыдущих результатов
                                    document.querySelector("#collapseEDA .accordion-body").innerHTML = "";
                                    document.querySelector("#div_corrmatrix_svg").innerHTML = "";

                                    // Развертывание аккордеона EDA
                                    new bootstrap.Collapse(document.getElementById('collapseEDA'), { toggle: true });

                                    // Создание кнопки для построения корреляционной матрицы
                                    const correlationMatrixButton = document.createElement("button");
                                    correlationMatrixButton.className = "btn btn-primary me-2";
                                    correlationMatrixButton.textContent = "Построить корреляционную матрицу";
                                    correlationMatrixButton.addEventListener("click", function () {
                                        // Проверка количества выбранных признаков
                                        if (features.length < 2) {
                                            alert("Выберите хотя бы два признака для построения корреляционной матрицы.");
                                            return;
                                        }
                                        // Создание кнопки для перехода на следующий этап
                                        if (document.querySelector("#id_nextButton")) {
                                            document.querySelector("#id_nextButton").remove();
                                        }
                                        const nextButton = document.createElement("button");
                                        nextButton.id = "id_nextButton";
                                        nextButton.className = "btn btn-primary me-2";
                                        nextButton.textContent = "Начать генетический алгоритм";
                                        nextButton.addEventListener("click", function () {
                                            ant_algorithm(data, features, "Class");
                                        });
                                        document.querySelector("#collapseEDA_2 .accordion-body").appendChild(nextButton);

                                        // Развертывание аккордеона с корреляционной матрицей
                                        new bootstrap.Collapse(document.getElementById('collapseEDA_2'), { toggle: true });
                                        // Создание и отображение корреляционной матрицы
                                        const correlationMatrixSvg = createCorrelationMatrixSvg(features, data);
                                        document.querySelector("#div_corrmatrix_svg").innerHTML = "";
                                        document.querySelector("#div_corrmatrix_svg").appendChild(correlationMatrixSvg);
                                    });
                                    document.querySelector("#collapseEDA .accordion-body").appendChild(correlationMatrixButton);

                                    // Создание списка признаков
                                    const featureList = document.createElement("div");
                                    featureList.className = "list-group";
                                    document.querySelector("#collapseEDA .accordion-body").appendChild(featureList);

                                    // Добавление признаков в список
                                    headers.forEach(header => {
                                        if (header === "id" || header === "Class") {
                                            return;
                                        }

                                        features.push(header);
                                        features.sort();

                                        // Создание элемента списка признака
                                        const featureItem = document.createElement("label");
                                        featureItem.className = "list-group-item d-flex gap-2";

                                        // Создание чекбокса для признака
                                        const checkbox = document.createElement("input");
                                        checkbox.type = "checkbox";
                                        checkbox.className = "form-check-input flex-shrink-0";
                                        checkbox.id = header;
                                        checkbox.checked = true;
                                        checkbox.addEventListener("change", function (e) {
                                            handleFeatureCheckboxChange(e.target, data, header);
                                        });

                                        // Создание метки для чекбокса
                                        const label = document.createElement("span");
                                        label.textContent = header;

                                        // Добавление элементов в DOM
                                        featureItem.appendChild(checkbox);
                                        featureItem.appendChild(label);
                                        featureList.appendChild(featureItem);

                                        // Создание и отображение гистограммы для признака
                                        const plotSvg = createHistogram(data, header);
                                        plots[header] = plotSvg;
                                        const plotDiv = document.createElement("div");
                                        plotDiv.id = `div_plt_id_${header.split(' ').join("_")}`;
                                        plotDiv.appendChild(plotSvg);
                                        document.querySelector("#collapseEDA .accordion-body").appendChild(plotDiv);
                                    });
                                };

                                reader.readAsText(file);
                            });

                            /**
                             * Функция для запуска генетического алгоритма.
                             * 
                             * @param {Array<object>} data - Массив объектов данных.
                             * @param {Array<string>} features - Массив выбранных признаков.
                             * @param {string} target_class - Название целевого класса.
                             */
                            function ant_algorithm(data, features, target_class){
                                // Количество особей и копируемых особей
                                var cnt_ants = 100, copy_ants = 10
                                // Вероятности мутации
                                var p_mutate_ch = 0.2
                                // Максимальная величина мутации операции
                                var p_mutate_op_rate = 0.1
                                // Множитель штрафа за количество итераций
                                var p_penalty = 1
                                // Степень влияния глубины дерева на штраф
                                var p_penalty_depth = 1
                                // Очистка предыдущих результатов
                                document.querySelector("#collapseAnt .accordion-body").innerHTML = "";

                                // Развертывание аккордеона с генетическим алгоритмом
                                new bootstrap.Collapse(document.getElementById('collapseAnt'), { toggle: true });

                                // Добавим слайдер для выбора количества особей
                                const slider_label = document.createElement("label");
                                slider_label.id = "slider_label";
                                slider_label.textContent = `Количество особей: ${cnt_ants}`;
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_label);
                                const slider = document.createElement("input");
                                slider.type = "range";
                                slider.min = 1;
                                slider.max = 1000;
                                slider.value = cnt_ants;
                                slider.className = "form-range";
                                slider.addEventListener("input", function () {
                                    cnt_ants = Number(slider.value);
                                    document.querySelector("#slider_label").textContent = `Количество особей: ${cnt_ants}`;
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider);

                                // Добавим слайдер для выбора количества копируемых особей
                                const slider_label_copy = document.createElement("label");
                                slider_label_copy.id = "slider_label_copy";
                                slider_label_copy.textContent = `Количество копируемых особей: ${copy_ants}`;
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_label_copy);

                                const slider_copy = document.createElement("input");
                                slider_copy.type = "range";
                                slider_copy.min = 1;
                                slider_copy.max = 100;
                                slider_copy.value = copy_ants;
                                slider_copy.className = "form-range";
                                slider_copy.addEventListener("input", function () {
                                    copy_ants = Number(slider_copy.value);
                                    document.querySelector("#slider_label_copy").textContent = `Количество копируемых особей: ${copy_ants}`;
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_copy);

                                // Добавим слайдер для выбора вероятности мутации признака
                                const slider_label_mutate_ch = document.createElement("label");
                                slider_label_mutate_ch.id = "slider_label_mutate_ch";
                                slider_label_mutate_ch.textContent = `Вероятность мутации признака: ${p_mutate_ch}`;
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_label_mutate_ch);

                                const slider_mutate_ch = document.createElement("input");
                                slider_mutate_ch.type = "range";
                                slider_mutate_ch.min = 0;
                                slider_mutate_ch.max = 1;
                                slider_mutate_ch.step = 0.01;
                                slider_mutate_ch.value = p_mutate_ch;
                                slider_mutate_ch.className = "form-range";
                                slider_mutate_ch.addEventListener("input", function () {
                                    p_mutate_ch = Number(slider_mutate_ch.value);
                                    document.querySelector("#slider_label_mutate_ch").textContent = `Вероятность мутации признака: ${p_mutate_ch}`;
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_mutate_ch);

                                // Добавим слайдер для выбора максимального отклонения при мутации
                                const slider_label_mutate_op_rate = document.createElement("label");
                                slider_label_mutate_op_rate.id = "slider_label_mutate_op_rate";
                                slider_label_mutate_op_rate.textContent = `Максимальное отклонение при мутации: ${p_mutate_op_rate}`;
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_label_mutate_op_rate);

                                const slider_mutate_op_rate = document.createElement("input");
                                slider_mutate_op_rate.type = "range";
                                slider_mutate_op_rate.min = 0;
                                slider_mutate_op_rate.max = 1;
                                slider_mutate_op_rate.step = 0.01;
                                slider_mutate_op_rate.value = p_mutate_op_rate;
                                slider_mutate_op_rate.className = "form-range";
                                slider_mutate_op_rate.addEventListener("input", function () {
                                    p_mutate_op_rate = Number(slider_mutate_op_rate.value);
                                    document.querySelector("#slider_label_mutate_op_rate").textContent = `Максимальное отклонение при мутации: ${p_mutate_op_rate}`;
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_mutate_op_rate);

                                // Добавим слайдер для выбора множителя штрафа за размер дерева
                                const slider_label_penalty = document.createElement("label");
                                slider_label_penalty.id = "slider_label_penalty";
                                slider_label_penalty.textContent = `Множитель штрафа за размер дерева: ${p_penalty}`;
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_label_penalty);

                                const slider_penalty = document.createElement("input");
                                slider_penalty.type = "range";
                                slider_penalty.min = 0;
                                slider_penalty.max = 50;
                                slider_penalty.step = 0.1;
                                slider_penalty.value = p_penalty;
                                slider_penalty.className = "form-range";
                                slider_penalty.addEventListener("input", function () {
                                    p_penalty = Number(slider_penalty.value);
                                    document.querySelector("#slider_label_penalty").textContent = `Множитель штрафа за размер дерева: ${p_penalty}`;
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_penalty);

                                // Добавим слайдер для выбора степени влияния глубины дерева на штраф
                                const slider_label_penalty_depth = document.createElement("label");
                                slider_label_penalty_depth.id = "slider_label_penalty_depth";
                                slider_label_penalty_depth.textContent = `Степень влияния глубины дерева на штраф: ${p_penalty_depth}`;
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_label_penalty_depth);

                                const slider_penalty_depth = document.createElement("input");
                                slider_penalty_depth.type = "range";
                                slider_penalty_depth.min = 0;
                                slider_penalty_depth.max = 10;
                                slider_penalty_depth.step = 0.1;
                                slider_penalty_depth.value = p_penalty_depth;
                                slider_penalty_depth.className = "form-range";
                                slider_penalty_depth.addEventListener("input", function () {
                                    p_penalty_depth = Number(slider_penalty_depth.value);
                                    document.querySelector("#slider_label_penalty_depth").textContent = `Степень влияния глубины дерева на штраф: ${p_penalty_depth}`;
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(slider_penalty_depth);

                                // Начнём генетический алгоритм
                                var ants = []

                                dataMins = {}, dataMaxs = {}
                                features.forEach((feature) => {
                                    dataMins[feature] = Math.min(...data.map((d) => Number(d[feature])))
                                    dataMaxs[feature] = Math.max(...data.map((d) => Number(d[feature])))
                                })

                                const make_ch = (feature, operation) => {
                                    return {class: feature, operation: operation}
                                }

                                function operation (value, class_header, threshold, lg){
                                    // console.log(value, class_header, threshold, lg, dataMaxs[class_header], dataMins[class_header])
                                    return lg ? value < (dataMaxs[class_header] - dataMins[class_header])*threshold + dataMins[class_header] : value > (dataMaxs[class_header] - dataMins[class_header])*threshold + dataMins[class_header]
                                }

                                const make_operation = (threshold, lg) => {
                                    function f(value, class_header){
                                        return operation(value, class_header, f.threshold, f.lg)
                                    }
                                    f.threshold = threshold
                                    f.lg = lg
                                    return f
                                }

                                const mutate_operation = (operation) => {
                                    let new_threshold = operation.threshold + (Math.random()*p_mutate_op_rate - p_mutate_op_rate/2)
                                    if (new_threshold < 0){
                                        new_threshold = Math.random()
                                    }else if (new_threshold > 1){
                                        new_threshold = Math.random()
                                    }
                                    return make_operation(new_threshold, Math.random() > 0.95? !operation.lg : operation.lg)
                                }

                                const mutate_ch = (ch) => {
                                    if (Math.random() > 0.95){
                                        return make_ch(features[Math.floor(Math.random()*features.length)],
                                                make_operation(Math.random(), Math.random() > 0.5))
                                    } else {
                                        return make_ch(ch.class, mutate_operation(ch.operation))
                                    }
                                }

                                const create_genome  = () => {
                                    return {
                                        left:null, // left child, выбирается если operation(data[feature]) == false
                                        right:null, // right child, выбирается если operation(data[feature]) == true
                                        ch: make_ch(features[Math.floor(Math.random()*features.length)], make_operation(Math.random(), Math.random() > 0.5))
                                    }
                                }

                                const mutate_genome = (genome) => {
                                    const r = Math.random()

                                    if(r < 0.7){
                                        return {
                                            left: genome.left ? mutate_genome(genome.left) : genome.left,
                                            right: genome.right ? mutate_genome(genome.right) : genome.right,
                                            ch: Math.random() > p_mutate_ch ? mutate_ch(genome.ch) : genome.ch
                                        }
                                    }
                                    else if (r < 0.8){
                                        if (Math.random() > 0.5){
                                            return {
                                                left: genome.left ? genome.left.left : create_genome(),
                                                right: genome.right,
                                                ch: genome.ch
                                            }
                                        } else {
                                            return {
                                                left: genome.left,
                                                right: genome.right ? genome.right.right : create_genome(),
                                                ch: genome.ch
                                            }
                                        }
                                    }
                                    else if(r < 0.9){
                                        let new_genome = create_genome()
                                        if (Math.random() > 0.5){
                                            new_genome.left = genome
                                        } else {
                                            new_genome.right = genome
                                        }
                                        return new_genome
                                    }else if(r < 0.95){
                                        if (Math.random() > 0.5){
                                            return genome.left ? genome.left : create_genome()
                                        } else {
                                            return genome.right ? genome.right : create_genome()
                                        }
                                    }else{
                                        return create_genome()
                                    }
                                }

                                const make_ant = (genome) => {
                                    return {
                                        genome: genome,
                                        fitness: 0
                                    }
                                }

                                const mutate_ant = (ant) => {
                                    return make_ant(mutate_genome(ant.genome))
                                }

                                const get_genome_depth = (genome) => {
                                    if (genome.left && genome.right){
                                        return 1 + Math.max(get_genome_depth(genome.left), get_genome_depth(genome.right))
                                    } else if (genome.left){
                                        return 1 + get_genome_depth(genome.left)
                                    } else if (genome.right){
                                        return 1 + get_genome_depth(genome.right)
                                    } else {
                                        return 1
                                    }
                                }

                                const get_genome_size = (genome) => {
                                    if (genome.left && genome.right){
                                        return 1 + get_genome_size(genome.left) + get_genome_size(genome.right)
                                    } else if (genome.left){
                                        return 1 + get_genome_size(genome.left)
                                    } else if (genome.right){
                                        return 1 + get_genome_size(genome.right)
                                    } else {
                                        return 1
                                    }
                                }

                                const score_ant = (ant) => {
                                    // пройдём map'ом по всем данным
                                    // let iters = 0;
                                    const score = data.map((d) => {
                                        let genome = ant.genome
                                        let cur_ans = false
                                        // let deph = 1
                                        while (genome){
                                            // iters+=deph
                                            res = genome.ch.operation(d[genome.ch.class], genome.ch.class)
                                            if (res){
                                                cur_ans = true
                                                genome = genome.right
                                                // deph *= p_penalty_depth
                                            } else {
                                                cur_ans = false
                                                genome = genome.left
                                                // deph *= p_penalty_depth
                                            }
                                        }
                                        return cur_ans ? d[target_class] == 1 : d[target_class] == 0
                                    }).reduce((a,b) => a + b, 0)
                                    return score - p_penalty*get_genome_size(ant.genome)*(get_genome_depth(ant.genome)**p_penalty_depth)
                                }

                                const create_ant = () => {
                                    return make_ant(create_genome())
                                }

                                const create_ants = (n) => {
                                    return Array(n).fill(0).map(() => create_ant())
                                }

                                const mutate_ants = (ants) => {
                                    return ants.map((ant) => mutate_ant(ant))
                                }

                                const score_ants = (ants) => {
                                    return ants.map((ant) => {
                                        ant.fitness = score_ant(ant)
                                        return ant
                                    })
                                }
                                
                                // выбор n лучших особей, чем больше score, тем лучше
                                const select_ants = (ants, n) => {
                                    return ants.sort((a,b) => b.fitness - a.fitness).slice(0,n)
                                }
                                const sleep = ms => new Promise(r => setTimeout(r, ms));

                                // document.querySelector("#collapseAnt .accordion-body").innerHTML = "";
                                const antButton = document.createElement("button");
                                antButton.className = "btn btn-primary me-2";
                                antButton.textContent = "Запустить генетический алгоритм";
                                var stop_flag = false
                                // создадим label для вывода результата
                                var iter = 0, prev_best=0;
                                antButton.addEventListener("click", async function () {
                                    if (copy_ants >= cnt_ants){
                                        alert("Количество копируемых особей не может быть больше или равно количеству особей")
                                        return
                                    }
                                    stop_flag = false
                                    ants = create_ants(cnt_ants)
                                    iter = 0, prev_best=0;
                                    while (!stop_flag){
                                        iter++
                                        ants = select_ants(score_ants(ants), copy_ants)
                                        if (prev_best != ants[0].fitness){
                                            document.querySelector("#result_label").textContent = `Поколение ${iter}: ${ants[0].fitness}`
                                            document.querySelector("#result_svg").innerHTML = ""
                                            const svg = svg_from_genome(ants[0].genome)
                                            const svgDiv = document.createElement("div");
                                            document.querySelector("#result_svg").appendChild(svgDiv);
                                            svgDiv.appendChild(svg);
                                            if (prev_best < ants[0].fitness){
                                                history.push({best_genome:ants[0].genome, best_score:ants[0].fitness, iter:iter, svg:svg})
                                            }
                                            prev_best = ants[0].fitness
                                        }
                                        for (let j = 0; j < cnt_ants - copy_ants; j++){
                                            ants.push(mutate_ant(ants[j % copy_ants]))
                                        }
                                        
                                        await sleep(1)
                                    }
                                });
                                // Кнопка остановки алгоритма
                                const antButton_stop = document.createElement("button");
                                antButton_stop.className = "btn btn-primary me-2";
                                antButton_stop.textContent = "Остановить генетический алгоритм";
                                antButton_stop.addEventListener("click", async function () {
                                    stop_flag = true
                                    console.log("Остановлено")
                                    await sleep(100)
                                    // console.log(ants)
                                    // Развернуть аккордеон с деревом решений
                                    new bootstrap.Collapse(document.getElementById('collapseTree'), { toggle: true });
                                    // Очистка предыдущих результатов
                                    document.querySelector("#collapseTree .accordion-body").innerHTML = "";

                                    const svg = svg_from_genome(ants[0].genome)
                                    const svgDiv = document.createElement("div");
                                    document.querySelector("#collapseTree .accordion-body").appendChild(svgDiv);
                                    svgDiv.appendChild(svg);

                                    history.push({best_genome:ants[0].genome, best_score:ants[0].fitness, iter:iter, svg:svg})
                                    
                                    // Создание кнопки для перехода на отображение истории
                                    if (document.querySelector("#id_historyButton")) {
                                        document.querySelector("#id_historyButton").remove();
                                    }
                                    const historyButton = document.createElement("button");
                                    historyButton.id = "id_historyButton";
                                    historyButton.className = "btn btn-primary me-2";
                                    historyButton.textContent = "Показать историю";
                                    historyButton.addEventListener("click", function () {
                                        // Развернуть аккордеон с историей
                                        new bootstrap.Collapse(document.getElementById('collapseHistory'), { toggle: true });
                                        // Очистка предыдущих результатов
                                        document.querySelector("#collapseHistory .accordion-body").innerHTML = "";
                                        // Вывод истории
                                        history.forEach((item) => {
                                            const svg = item.svg
                                            const svgDiv = document.createElement("div");
                                            svgDiv.style = "margin-top: 10px; border: 1px solid black; width: fit-content";
                                            document.querySelector("#collapseHistory .accordion-body").appendChild(svgDiv);
                                            svgDiv.appendChild(svg);
                                            const label = document.createElement("label");
                                            label.textContent = `Поколение ${item.iter}: ${item.best_score}`;
                                            label.style = "margin-top: 10px; margin-bottom: 10px; display: block; font-size: 20px;";
                                            document.querySelector("#collapseHistory .accordion-body").appendChild(label);
                                        });
                                    });
                                    document.querySelector("#collapseTree .accordion-body").appendChild(historyButton);
                                });
                                document.querySelector("#collapseAnt .accordion-body").appendChild(antButton);
                                document.querySelector("#collapseAnt .accordion-body").appendChild(antButton_stop);

                                if (!document.querySelector("#result_label")){
                                    const result_label = document.createElement("label");
                                    result_label.id = "result_label"
                                    document.querySelector("#collapseAnt .accordion-body").appendChild(result_label);
                                }else{
                                    document.querySelector("#result_label").textContent = ""
                                }

                                if (!document.querySelector("#result_svg")){
                                    const result_label = document.createElement("div");
                                    result_label.id = "result_svg"
                                    document.querySelector("#collapseAnt .accordion-body").appendChild(result_label);
                                }else{
                                    document.querySelector("#result_svg").textContent = ""
                                }

                            }

                            function svg_from_genome(genome){
                                // console.log(genome)
                                function genome_to_dot(genome, parent_id = null, is_right = false){
                                    // console.log(genome)
                                    const id = "id_"+Math.random().toString(36).substring(2, 15)
                                    const tr = (dataMaxs[genome.ch.class] - dataMins[genome.ch.class])*genome.ch.operation.threshold + dataMins[genome.ch.class]
                                    let dot = ""
                                    if (parent_id){
                                        dot += `${id} [label="${genome.ch.class} ${genome.ch.operation.lg ? '<' : '>'} ${tr.toFixed(2)}\\n"];\n`
                                        dot += `${parent_id} -> ${id} [label="${is_right ? 'Да' : 'Нет'}"];\n`
                                    }else{
                                        dot += `${id} [label="${genome.ch.class} ${genome.ch.operation.lg ? '<' : '>'} ${tr.toFixed(2)}\\n"];\n`
                                    }
                                    if (genome.left){
                                        dot += genome_to_dot(genome.left, id, false)
                                    } else {
                                        dot += `${id}_left [label="Рис Гонён"];\n`
                                        dot += `${id} -> ${id}_left [label="Нет"];\n`
                                    }
                                    if (genome.right){
                                        dot += genome_to_dot(genome.right, id, true)
                                    } else {
                                        dot += `${id}_right [label="Рис Жасмин"];\n`
                                        dot += `${id} -> ${id}_right [label="Да"];\n`
                                    }
                                    return dot
                                }
                                const dot = `digraph {\nnode [shape=box];\n${genome_to_dot(genome)}}`
                                // console.log(dot)
                                const svg = document.createElement("div");
                                d3.select(svg)
                                    .graphviz()
                                    .dot(dot)
                                    .render();
                                return svg
                            }

                            /**
                             * Обработчик события изменения состояния чекбокса признака.
                             *
                             * @param {HTMLInputElement} checkbox - Чекбокс признака.
                             * @param {Array<object>} data - Массив объектов данных.
                             * @param {string} header - Заголовок столбца данных.
                             */
                            function handleFeatureCheckboxChange(checkbox, data, header) {
                                if (checkbox.checked) {
                                    // Добавление признака в список выбранных
                                    if (!features.includes(header)) {
                                        features.push(header);
                                        features.sort();
                                    }

                                    // Отображение гистограммы
                                    document.querySelector(`#div_plt_id_${header.split(' ').join("_")}`).innerHTML = "";
                                    document.querySelector(`#div_plt_id_${header.split(' ').join("_")}`).appendChild(plots[header]);
                                } else {
                                    // Удаление признака из списка выбранных
                                    features.splice(features.indexOf(header), 1);

                                    // Скрытие гистограммы
                                    document.querySelector(`#div_plt_id_${header.split(' ').join("_")}`).innerHTML = "";
                                }
                            }

                            /**
                             * Создает SVG-элемент для гистограммы.
                             *
                             * @param {Array<object>} data - Массив объектов данных.
                             * @param {string} header - Заголовок столбца данных.
                             * @returns {HTMLElement} - Созданный SVG-элемент.
                             */
                            function createHistogram(data, header) {
                                const numData = data.map(d => Number(d[header])).filter(d => !isNaN(d));
                                const interval = (Math.max(...numData) - Math.min(...numData)) / Math.ceil(Math.sqrt(numData.length));

                                return Plot.plot({
                                    width: 800,
                                    height: 400,
                                    x: { label: header },
                                    y: { label: "Count" },
                                    aspectRatio: 1,
                                    marks: [
                                        Plot.rectY(data, Plot.binX({ y: "count" }, { x: header, fill: "steelblue", interval })),
                                        Plot.lineY(
                                            data.filter(d => d.Class === "1"),
                                            Plot.binX({ y: "count" }, { x: header, stroke: "red", strokeDasharray: "5,5", strokeWidth: 3, interval })
                                        ),
                                        Plot.lineY(
                                            data.filter(d => d.Class === "0"),
                                            Plot.binX({ y: "count" }, { x: header, stroke: "green", strokeDasharray: "5,5", strokeWidth: 3, interval })
                                        )
                                    ]
                                });
                            }

                            /**
                             * Создает SVG-элемент для корреляционной матрицы.
                             *
                             * @param {Array<string>} headers - Массив заголовков столбцов данных.
                             * @param {Array<object>} data - Массив объектов данных.
                             * @returns {HTMLElement} - Созданный SVG-элемент.
                             */
                             function createCorrelationMatrixSvg(headers, data) {
                                const filteredHeaders = headers.filter(h => h !== "id" && h !== "Class");

                                // Размеры и отступы графика
                                const margin = { top: 30, right: 30, bottom: 200, left: 200 };
                                const width = 750 - margin.left - margin.right;
                                const height = 750 - margin.top - margin.bottom;

                                // Создание контейнера для SVG
                                const svgDiv = document.createElement("div");

                                // Создание SVG-элемента
                                const svg = d3.select(svgDiv)
                                    .append("svg")
                                    .attr("width", width + margin.left + margin.right)
                                    .attr("height", height + margin.top + margin.bottom)
                                    .append("g")
                                    .attr("transform", `translate(${margin.left},${margin.top})`);

                                // Масштабирование осей
                                const xScale = d3.scaleBand()
                                    .range([0, width])
                                    .domain(filteredHeaders)
                                    .padding(0.01);

                                const yScale = d3.scaleBand()
                                    .range([height, 0])
                                    .domain(filteredHeaders)
                                    .padding(0.01);

                                // Создание осей
                                svg.append("g")
                                    .attr("transform", `translate(0, ${height})`)
                                    .call(d3.axisBottom(xScale))
                                    .selectAll("text")
                                    .attr("transform", "translate(-10,0)rotate(-45)")
                                    .style("text-anchor", "end")
                                    .style("font-size", "14px");

                                svg.append("g")
                                    .call(d3.axisLeft(yScale))
                                    .selectAll("text")
                                    .style("font-size", "14px");

                                // Создание всплывающей подсказки
                                const tooltip = d3.select(svgDiv)
                                    .append("div")
                                    .attr("class", "tooltip");

                                // Обработчики событий мыши
                                const mouseover = function () {
                                    tooltip.style("opacity", 1);
                                    d3.select(this)
                                        .style("stroke", "black")
                                        .style("opacity", 1);
                                };

                                const mousemove = function (event, d) {
                                    tooltip
                                        .html("Correlation: " + d.value)
                                        .style("left", event.pageX + "px")
                                        .style("top", event.pageY + "px");
                                };

                                const mouseleave = function () {
                                    tooltip.style("opacity", 0);
                                    d3.select(this)
                                        .style("stroke", "none")
                                        .style("opacity", 0.8);
                                };

                                // Вычисление корреляционной матрицы
                                const correlationMatrix = calculateCorrelationMatrix(data, filteredHeaders);

                                // Цветовая шкала
                                const colorScale = d3.scaleLinear()
                                    .range(["blue", "white", "red"])
                                    .domain([-1, 0, 1]);

                                // Отрисовка ячеек матрицы
                                svg.selectAll()
                                    .data(correlationMatrix)
                                    .enter()
                                    .append("g")
                                    .selectAll()
                                    .data((d, i) => d.map((value, j) => ({ i, j, value })))
                                    .enter()
                                    .append("rect")
                                    .attr("x", d => xScale(filteredHeaders[d.i]))
                                    .attr("y", d => yScale(filteredHeaders[d.j]))
                                    .attr("width", xScale.bandwidth())
                                    .attr("height", yScale.bandwidth())
                                    .style("fill", d => colorScale(d.value))
                                    .style("opacity", 0.8)
                                    .on("mouseover", mouseover)
                                    .on("mousemove", mousemove)
                                    .on("mouseleave", mouseleave);

                                return svgDiv;
                            }

                            /**
                             * Вычисляет корреляционную матрицу для заданных данных и заголовков столбцов.
                             *
                             * @param {Array<object>} data - Массив объектов данных.
                             * @param {Array<string>} headers - Массив заголовков столбцов данных.
                             * @returns {Array<Array<number>>} - Корреляционная матрица.
                             */
                            function calculateCorrelationMatrix(data, headers) {
                                const matrix = [];
                                for (let i = 0; i < headers.length; i++) {
                                    matrix[i] = [];
                                    for (let j = 0; j < headers.length; j++) {
                                        matrix[i][j] = getCorrelation(data, headers[i], headers[j]);
                                    }
                                }
                                return matrix;
                            }

                            /**
                             * Вычисляет коэффициент корреляции Пирсона между двумя столбцами данных.
                             *
                             * @param {Array<object>} data - Массив объектов данных.
                             * @param {string} header1 - Заголовок первого столбца.
                             * @param {string} header2 - Заголовок второго столбца.
                             * @returns {number} - Коэффициент корреляции.
                             */
                            function getCorrelation(data, header1, header2) {
                                const xData = data.map(d => Number(d[header1])).filter(d => !isNaN(d));
                                const yData = data.map(d => Number(d[header2])).filter(d => !isNaN(d));
                                const xMean = d3.mean(xData);
                                const yMean = d3.mean(yData);
                                const numerator = xData.map((d, i) => (d - xMean) * (yData[i] - yMean)).reduce((a, b) => a + b, 0);
                                const denominator = Math.sqrt(
                                    xData.map(d => (d - xMean) ** 2).reduce((a, b) => a + b, 0) *
                                    yData.map(d => (d - yMean) ** 2).reduce((a, b) => a + b, 0)
                                );
                                return numerator / denominator;
                            }
                        </script>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingEDA">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseEDA" aria-expanded="false" aria-controls="collapseEDA">
                        EDA анализ 1 - Выбор признаков
                    </button>
                </h2>
                <div id="collapseEDA" class="accordion-collapse collapse" aria-labelledby="headingEDA"
                    data-bs-parent="#analysisAccordion">
                    <div class="accordion-body">

                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingEDA_2">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseEDA_2" aria-expanded="false" aria-controls="collapseEDA_2">
                        EDA анализ 2 - Корреляционная матрица
                    </button>
                </h2>
                <div id="collapseEDA_2" class="accordion-collapse collapse" aria-labelledby="headingEDA_2"
                    data-bs-parent="#analysisAccordion">
                    <div class="accordion-body">
                        <div id="div_corrmatrix_svg"> </div>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingAnt">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseAnt" aria-expanded="false" aria-controls="collapseAnt">
                        Генетический алгоритм
                    </button>
                </h2>
                <div id="collapseAnt" class="accordion-collapse collapse" aria-labelledby="headingAnt"
                    data-bs-parent="#analysisAccordion">
                    <div class="accordion-body">
                        <!-- Секция для визуализации генетического алгоритма -->
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingTree">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseTree" aria-expanded="false" aria-controls="collapseTree">
                        Результирующее дерево решений
                    </button>
                </h2>
                <div id="collapseTree" class="accordion-collapse collapse" aria-labelledby="headingTree"
                    data-bs-parent="#analysisAccordion">
                    <div class="accordion-body">
                        <!-- Секция для отображения дерева решений -->
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingHistory">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseHistory" aria-expanded="false" aria-controls="collapseHistory">
                        История поколений
                    </button>
                </h2>
                <div id="collapseHistory" class="accordion-collapse collapse" aria-labelledby="headingTree"
                    data-bs-parent="#analysisAccordion">
                    <div class="accordion-body">
                        <!-- Секция для отображения истории поколений -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>